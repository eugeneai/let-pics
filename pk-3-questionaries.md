////// # ПК-3. Способен выбирать и применять методы инженерии знаний для создания систем, основанных на знаниях

////// ## ПК-3.1. Выбирает и применяет методы сбора и извлечения знаний

// Извлечение знаний
::ПК-3.1-1::Предсказание метеорологами погоды имеет 75% достоверность. Можно ли считать предметную область формализуемой в "четкой" логике первого порядка {FALSE}.

// Логический формализм - распознать на примерах.
::ПК-3.1-2::[html]Какое из перечисленных представлений относится к логическому формализму представления знаний. {
~<code>If ?subject is human then ?subject is mortal<code> # Продукционный формализм
=<code>mortal(Subject) :- human(Subject).<code>
~<img width\=600 src\="https://raw.githubusercontent.com/eugeneai/leti-pics/master/frames-ex1.svg"/>
<!-- `  human                                        mortal                  `\n -->
<!-- `+---------------------+-------------+  +--\->+--------------+----------+`\n -->
<!-- `|   is a              |      *------+--+    |              |          |`\n -->
<!-- `+---------------------+-------------+       +--------------+----------+`\n -->
<!-- `|   name              | Socrates    |       | living being |  yes     |`\n -->
<!-- `+---------------------+-------------+       +--------------+----------+`\n -->
<!-- `|   size, m           | 1.65        |       | birth date   |          |`\n -->
<!-- `+---------------------+-------------+       +--------------+----------+`\n -->
<!-- `|   nationality       | Grece       |       | death date   |          |`\n -->
<!-- `+---------------------+-------------+       +--------------+----------+`\n -->
<!-- `|   birth date        | 470 BC      |       |              |          |`\n -->
<!-- `+---------------------+-------------+       +--------------+----------+`\n -->
<!-- `|   death date        | 399 BC      |       |              |          |`\n -->
<!-- `+---------------------+-------------+       +--------------+----------+`\n -->
~<img width\=600 src\="https://raw.githubusercontent.com/eugeneai/leti-pics/master/network-ex1.svg"/>
<!-- `+-------------+                    +----------------+                  `\n -->
<!-- `| Socrates    |----- is a -------\->|  Human         |                  `\n -->
<!-- `+-------------+                    +----------------+                  `\n -->
<!-- `                                            |                          `\n -->
<!-- `                                            | generic property         `\n -->
<!-- `                                            v                          `\n -->
<!-- `                                   +----------------+                  `\n -->
<!-- `                                   |  Mortal        |                  `\n -->
<!-- `                                   +----------------+                  `\n -->
}

////// ### ПК-3.1. З-1. Знает методологические подходы к выбору и разработке методов получения знаний инженером по знаниям от экспертов; извлечения знаний из данных и текстов и применения соответствующих инструментальных средств

::ПК-3.1-З-1.1::Технический английский язык отличается от естественного английского: {
~%50%Каждый термин задает только одно значение.
~Всегда ограничен синтаксически контекстно-свободной грамматикой.
~Не использует вспомогательных глаголов.
~Использует только повествовательные формы предложений.
~%50%Каждая структура языка интерпретируется однозначно.
}

::ПК-3.1-З-1.2::Что мешает использованию естественного языка для представления знаний? {
~%50%Неоднозначность интерпретации значения слов и структур.
~%50%Сложный синтаксис.
~Использование имен собственных в качестве существительных.
~Использование большого количества букв алфавита.
}

::ПК-3.1-З-1.3::Программа Protege предназначена для {
~%50%Проектирования онтологии.
~%25%Преобразования форматов записи троек графов знаний.
~%25%Верификации концептуальных моделей, представленных в RDF.
~Рисовать когнитивные графы.
~Анализировать уровень защищенности информационной системы от DDOS-атак.
}

::ПК-3.1-З-1.4::Инженеру знаний для успешного достижения цели (разработки базы знаний) необходимо: {
~%50%Проводить консультации с экспертом, если сам не является экспертом в предметной области.
~%50%Разбираться в вопросах представления и обработки знаний.
~Уметь проектировать тесты интерфейсов пользователя баз данных.
~Обладать навыками конвертации форматов геоинформационных систем.
}


////// ### ПК-3.1. У-1. Умеет выбирать и применять методы и средства получения знаний инженером по знаниям от экспертов; извлечения знаний из данных и текстов

// # Представление в форме RDF
// Пример построения классификации из предложения "Рыболовство, спорт, компьютерный игры и другие виды хобби"
::ПК-3.1-У-1.1::[markdown]Какие наборы кортежей формализуют фразу "... рыболовство, спорт, компьютерный игры и другие виды хобби..." в графе знаний? {
~
`    <Fishing> a <Hobby> .`\n
`    <Sport> a <Hobby> .`\n
`    <Gaming> a <Hobby> .`\n
~%50%
`    <Fishing> rdfs:subClassOf <Hobby> .`\n
`    <Sport> rdfs:subClassOf <Hobby> .`\n
`    <Gaming> rdfs:subClassOf <Hobby> .`\n
#Ну да, только тип объекта, например, <Fishing> не задан.
~%50%
`    <Hobby> a a rdfs:Class .`\n
`    <Fishing> a rdfs:Class .`\n
`    <Sport> a rdfs:Class .`\n
`    <Gaming> a rdfs:Class .`\n
#Да, но только отношения вложенности терминов не заданы.
~
`    <Fishing> rdfs:subProperyOf <Hobby> .`\n
`    <Sport> rdfs:subProperyOf <Hobby> .`\n
`    <Gaming> rdfs:subProperyOf <Hobby> .`\n
#Неправильно. Все <ресурсы> здесь - названия классов, а не свойства других объектов.
}

// Пример "Все резьбы на шпинделях являются левыми"
::ПК-3.1-У-1.2::[markdown]Какие из перечисленных ниже форм записи формализуют фразу "Все резьбы (screw-thread) на шпинделях с правым оборотом (spindle) являются левыми"? {
~%50%
`    screwthread(S,left):-`\n
`        spindle(S),`\n
`        rotates(S,right).`\n
~%50%$$\forall s (spindle(s)\& rotates(s,right)\to screwthread(s,left))$$
~Не существует шпинделя, вращающегося направо с правой резьбой.#Да, эта фраза идентична по смыслу, но не является строго формализованной.
~Формализация фразы невозможна.#В принципе, такие фразы возможны, но этот случай точно формализуем.
}

// Пример "В здоровом организме отсутствует интересующий нас болезнетворный микроорганизм"
::ПК-3.1-У-1.3::[markdown]Какие из перечисленных ниже форм записи формализуют фразу "В здоровом организме отсутствует интересующий нас болезнетворный микроорганизм". {
=
`    ill(Organism):-`\n
`        harmful(Bacteria),`\n
`        located(Organism,Bacteria).`\n
~
`    healthy(Organism):-`\n
`        harmful(Bacteria),`\n
`        located(Organism,Bacteria).`\n
~
`    ill(Organism):-`\n
`        harmful(Bacteria),`\n
`        \+ located(Organism,Bacteria).`\n
~
`    ill(Organism):-`\n
`        located(Organism,_).`\n
#Неправильно, не всякий обнаруженный микроорганизм является болезнетворным
}

// Ни один из пациентов не любит знахарей
::ПК-3.1-У-1.4::Какие из перечисленных ниже формул задают фразу "Ни один из пациентов не любит знахарей (quack)" в языке исчисления предикатов первого порядка. {
~%25% $$\\neg \exists x (patient(x)\&\forall y (quack(y)->\\neg likes(x,y)))$$
~%25% $$\forall x (patient(x)->\forall y (quack(y)->\\neg likes(x,y)))$$
~%25% $$\forall x (patient(x)->\\neg \exists y (quack(y)\& likes(x,y)))$$
~%25% $$\\neg \exists x \\neg \exists y (patient(x)\& quack(y)\& likes(x,y)))$$
} // # Все из перечисленных формул эквивалентны и формализуют эту фразу.

////// ## ПК-3.2. Выбирает и применяет методы структурирования знаний

// A-Box, T-Box
::ПК-3.2-1::Экземпляры предметной области, особенно в ее изменяемой (эволюционирующей) части формируют {~T-=A-~I-~E-}Box онтологии.

// Knowledge Graph
::ПК-3.2-1::T-Box - Это {
=Часть графа знаний, задающая базовые термины и отношения в предметной области
~Часть графа знаний, задающая набор конкретных объектов (например, объекты в базе данных) предметной области
~Модель интерфейса пользователя системы, основанной на формализованных знаниях
~Описание интерфейса прикладного программирования (API) библиотеки
}

////// ### ПК-3.2. З-1. Знает методологические подходы к выбору и применению методов структурирования знаний для предметных областей в виде ментальных карт, таксономий, деревьев целей и решений

// Интерпретация дерева решений в виде Пролог-правил
::ПК-3.2-З-1.1::[html]Дано дерево решений <br> <img width\=600 src\="https://raw.githubusercontent.com/eugeneai/leti-pics/master/titanic.svg"/> <br/> Какие правила на языке Prolog соответствуют этому дереву? {
~%50%
<code>
    dead(X):-man(X),age(X,A),A&gt;9.5.
    dead(X):-man(X),age(X,A),A\=&lt;9.5,relatives(X,R),R&gt;2.5.
</code>
~%50%
<code>
    survived(X):-woman(X);man(X),age(X,A),A\=&lt;9.5,relatives(X,R),R\=&lt;2.5.
</code>
~
<code>
    dead(X):-man(X);woman(X).
</code>
~
<code>
    survived(X):-cat(X);dog(X).
</code>
~
<code>
    survived(X):-capitan(X).
</code>
}

// Соответствие правила пролога интерпретации
::ПК-3.2-З-1.2::[markdown]В исчислении предикатов, теории первого порядка, задана теория $$\forall x (h(x)\to m(x))\& h(socrates)$$. Какая форма записи соответствует программе в языке Prolog {
=
`    h(socrates).`\n
`    m(X):-h(X).`\n
~
`    m(socrates).`\n
`    m(X):-h(X).`\n
~
`    h(socrates).`\n
`    m(X),h(X).`\n
~
`    m(socrates).`\n
`    h(X).`\n
}

// инкапсуляция правил пролога в объекте
::ПК-3.2-З-1.3::[markdown]Задан объект Logtalk, допишите объект, чтобы запрос `tie::shirt(red,X)` выдавал `X=white`.\n
`   :- object(tie)`\n
`        :- public(tie/2).`\n
`        shirt(blue,red).`\n
`        {=shirt(red,blue)=shirt(red, blue)}.`\n
`        shirt(white,red).`\n
`   :- end_object.`\n

// построение системы типов/классов
::ПК-3.2-З-1.4::[markdown]Какие из следующих описаний задают знание, что все кошки (как класс) - млекопитающие (класс)? {
~
`    <Cat> a <Mammal>`\n
~%50%
`    <Cat> rdfs:subClassOf <Mammal>`\n
#Да, это в RDF!
~%50%
`    mammal(X):-cat(X).`\n
#Правильно, это на языке Prolog
~
`    <Cat> rdfs:subProperyOf <Mammal>`\n
~
`    <Cat> is <Mammal>`\n
}

////// ### ПК-3.2. У-1. Умеет выбирать и применять методы структурирования знаний для построения концептуальных моделей знаний (онтологий знаний)

// rdfs:label
::ПК-3.2.У-1.1::[markdown]Какие формы записи соответствуют определению: Название класса `<Class>` - это `"Шишка"` ? {
~%50%
`   <Class> rdfs:label "Шишка"`
~%50%
`   <Class> rdfs:label "Шишка"@ru`
~
`    <Class> a "Шишка"`
~
`    <Class> rdfs:range "Шишка"`
~
`    <Class> rdfs:domain "Шишка"`
}

// предикат subClassOf
::ПК-3.2.У-1.2::[markdown]Какая форма записи соответствует определению: Класс `<ClassS>` является подклассом класса `<ClassP>`? {
=
`    <ClassS> rdfs:subClassOf <ClassP>`
~
`    <ClassS> rdfs:subProperyOf <ClassP>`
~
`    <ClassS> a <ClassP>`
~
`    <ClassS> rdfs:domain <ClassP>`
}

// subProperyOf
::ПК-3.2.У-1.3::[markdown]Какая форма записи соответствует определению: предикат/свойство `<P1>` является производным свойством от `<P2>`? {
~
`    <P1> rdfs:subClassOf <P2>`
=
`    <P1> rdfs:subProperyOf <P2>`
~
`    <P1> a <P2>`
~
`    <P1> rdfs:domain <P2>`
}

// a, rdf:type
::ПК-3.2.У-1.4::[markdown]Какие формы записи соответствуют определению: Экземпляр `<instance>` относится к классу `<Class>`? {
~%50%
`    <instance> a <Class>`
#Короткая форма записи rdf:type.
~%50%
`    <instance> rdf:type <Class>`
~
`    <instance> rdf:instance <Class>`
~
`    <instance> is <Class>`
}


////// ## ПК-3.3. Выбирает и применяет методы представления знаний

// logical formalism
::ПК-3.3-1::Какие из перечисленных формализмов используются для представления знаний в системах, основанных на формализованных знаниях: {
~%25%Логический формализм
~%25%Продукционный формализм
~%25%Семантические сети
~%25%Фреймы
~База данных прецедентов
~Нейронная сеть Кохонена
~Перцетрон
~Генетический алгоритм
~Генетическое программирование
}

// Semantic web triple
::ПК-3.3-2:: [markdown]Структура кортежа (тройки) в Семантическом Вебе - `<субъект,{=предикат=свойство=predicate=property},объект>`.

////// ### ПК-3.3. З-1. Знает методологические подходы к выбору и применению методов представления знаний с помощью логических и продукционных методов, семантических сетей и фреймов, объектноориентированных методов

// LOOP manipualation assets (наследование, инкапсуляция, композиция)
// Ontology inference from sources
// Conversion from UML to KG
// Инкапсуляция SPARQL-запросов.

////// ### ПК-3.3. У-1. Умеет выбирать и применять методы представления знаний для проектирования базы знаний для предметных областей

// Logtalk object structure
// Logtalk prototype inheritance
// Incapsulation and protocols
// Categories as sub-KB

////// ## ПК-3.4. Выбирает и применяет методы построения логических выводов на основе знаний

// Horn phrases
::ПК-3.4-1::[markdown]Какие из перечисленных формул/описаний выполняют ограничения Хорна? {
~%50%
    likes_cookies(X):-
        h(X),eats(X,cookies).
~%50%$$\forall x(h(x)->m(x))$$
~$$\forall x(h(x)\& likesAllWinterAthletics(x)->likes(x,skiing)\vee likes(x,scating))$$
~Ни одна из перечисленных форм.
}

// Resolutional principle
::ПК-3.4-2::[markdown]Применение правила резолюции к фразам (`m :- h. h :- p.`) породит дизъюнкт: {
=`m :- p.`
~пустой дизъюнкт $$\bot$$
~`p :- m.`
~`p.`
~`m.`
~`h.`
}

////// ### ПК-3.4. З-1. Знает методологические подходы к выбору и применению построения логических выводов на основе знаний с помощью дедукции, индукции и абдукции, согласования экспертных оценок и нечеткого вывода

// Unification
::ПК-3.4-З-1.1::В результате наибольшей общей унификации $$X=Y$$ по правилам языка Пролог выражений $$X = 5 * (3 + C)$$ и $$Y=Q * (K + B)$$ получится следующее множество подстановок: {
=$$\{Q\=5, K\=3, B\=C\}$$.
~$$\{Q\=L, K\=3, B\=C\}$$.
~$$\{Q\=5, K\=3, B\=8\}$$.# Унификация, но не наиболее общая
~$$\{Q\=5, K\=3, B\=Q\}$$.
~Термы $$X$$ и $$Y$$ неунифицируемы
}

// Метод от противного в языке первого порядка
::ПК-3.4-З-1.2::При использовании метода "от противного" при доказательстве непротиворечивости $$A_1\=\forall x(h(x)\to m(x)), A_2\=h(s), A_1\&A_2\to m(s)$$ необходимо рассматривать частный случай A_1, при $$x\=$${
=$$s$$
~$$5$$
~$$y$$
~$$A_2$$}

// Семантика Modus ponens
::ПК-3.4-З-1.3::Правило Modus ponens $$\alpha\to\beta, \alpha\vdash\beta$$ означает, что {
=Если в ряде выведенных формул есть две формулы, имеющие структуры $$\alpha\to\beta$$ и $$\alpha$$, то можно в этот ряд добавить формулу $$\beta$$.
~Если в ряде выведенных формул есть две формулы, имеющие структуры $$\alpha\to\beta$$ и $$\beta$$, то можно в этот ряд добавить формулу $$\alpha$$.
~Если в ряде выведенных формул есть две формулы, имеющие структуры $$\alpha\to\beta$$ и $$\alpha$$, то нужно в этом ряду удалить формулу $$\beta$$.
~Ни одно из перечисленного.
}

// Частный случай высказывания
::ПК-3.4-З-1.4::Какие из перечисленных формул являются частным случаем $$\forall x (h(x)\to m(x))$$? {
=$$h(s)\to m(s)$$, $$s$$ -- константа.
~$$m(x)\to h(x)$$.
~$$\\neg \forall x (h(x)\to m(x))$$.
~$$h(s)$$
}

////// ### ПК-3.4. У-1. Умеет выбирать и применять методы построения логических выводов для разработки программных компонентов систем, основанных на знаниях, и приложений

// Logtalk qery structure
::ПК-3.4-У-1.1::[markdown]Какая из следующих структур является вызовом метода объекта в Logtalk?{
~%50%?- `cat::say(Meuw).`# Вызов метода объекта.
~?- `say(cat,Meuw)`.
~%50%`^^say(Sound).`# Вызов предка из контекста объекта...
~`[program.pl]`.
~`consult(user)`.
}

// ::/2, ::/1, ^^/1 operators
::ПК-3.4-У-1.2::Сопоставьте вызов метода с соответствующим оператором. {
=Вызов метода объекта->::/2
=Вызов своего метода->::/1
=Вызов родительского->^^/1
=Загрузка программы Logtalk->\{\}/1
}

// Object query
::ПК-3.4-У-1.3::[markdown]Задан объект Logtalk, допишите объект, чтобы запрос `tie::shirt(red,X)` выдавал `X=white`.\n
`   :- object(tie)`\n
`        :- {public}(tie/2).`\n
`        shirt(blue,red).`\n
`        shirt(red,blue).`\n
`        shirt(white,red).`\n
`   :- end_object.`\n

// Parametric object query
::ПК-3.4-У-1.4::[html]Задана теория Logtalk<br/>
<code>
:- object(circle(_Radius, _Color)).<br/>
    %<br/>
    :- public([<br/>
        area/1, perimeter/1<br/>
    ]).<br/>
    %<br/>
    area(Area) :-<br/>
        parameter(1, Radius),<br/>
        Area is pi*Radius*Radius.<br/>
    %<br/>
    perimeter(Perimeter) :-<br/>
        parameter(1, Radius),<br/>
        Perimeter is 2*pi*Radius.<br/>
    %<br/>
:- end_object.<br/>
%<br/>
circle(1.00, blue).<br/>
circle(3.71, yellow).<br/>
circle(0.39, green).<br/>
circle(5.74, black).<br/>
circle(8.32, cyan).<br/>
<code><br/>
Восстановите результат запроса.<br/>
<code>
?- findall(Area, \{circle(_, _)\}::area(Area), Areas).<br/>
Areas = [{#3.141..3.142}, 43.2412, 0.477836, 103.508, 217.468]<br/>
yes<br/>
<code>
